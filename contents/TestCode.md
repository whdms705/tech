### mock
>> 실제 객체를 만들어 사용하기에 시간, 비용 등의 Cost가 높거나 혹은 객체 서로간의 의존성이 강해 구현하기 힘들 경우 가짜 객체를 만들어 사용하는 방법이다.

`언제사용하는가?`<br>
* 테스트 작성을 위한 환경 구축이 어려운 경우
* 테스트가 특정 경우나 순간에 의존적인 경우
* 테스트 시간이 오래 걸리는 경우
* 개인 PC의 성능이나 서버의 성능문제로 오래 걸릴수 있는 경우 시간을 단축하기 위해 사용한다.


### Mockito
>> java mock framework

`Mockito 메소드 종류`<br>
* Mock() - 모의 객체를 생성하는 역할
* when() - 협력객체 메소드 반환 값을 지정해주는 역할(stub)
* verify() - SUT안의 협력객체 메소드가 호출 되었는지 확인
* times() - 지정한 횟수 만큼 협력 객체 메소드가 호출 되었는지 확인
* never() - 호출되지 않았는지 여부 검증
* atLeastOnce() - 최소 한 번은 특정 메소드가 호출되었는지 확인
* atLeast() - 최소 지정한 횟수 만큼 호출되었는지 확인
* atMost() - 최대 지정한 횟수 만큼 호출되었는지 확인
* clear() - 스텁을 초기화 한다
* timeOut() - 지정된 시간 안에 호출되었는지 확인


`@Spy와 @Mock의 차이`<br>
둘의 가장 큰 차이점은 @Spy는 실제 인스턴스를 사용해서 mocking을 하고,<br>
@Mock은 실제 인스턴스 없이 가상의 mock 인스턴스를 직접 만들어 사용한다는 것이다.<br>
그래서 @Spy는 Mockito.when() 이나 BDDMockito.given() 메서드 등으로 메서드의 행위를 지정해 주지 않으면<br>
@Spy 객체를 만들 때 사용한 실제 인스턴스의 메서드를 호출한다.