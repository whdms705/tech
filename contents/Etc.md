# ETC

**:Contents**
* [결합인덱스로 트러블 이슈 해결하기](#트러블이슈해결1)
* [비동기 처리로 API timeout 케이스 대비하기](#트러블이슈해결2)
* [힌트를 이용한 인덱스 강제 지정](#sql튜닝)
* [ehcache 적용을 통해 카테고리 조회 개선](#개선)

---

### 트러블이슈해결1
일배치에 집계에서 DB분리와 메세지 큐를 이용한 집계 방식으로 전환 하는 작업에서<br> 
파트너번호와 거래일자를 메세지 큐에 쌓고 consumer역할을 하는 application에서 집계하는 과정에서<br> 
디비 지연이 발생하는 트러블 이슈가 생김.<br> 

DB파트에서 디비 지연을 일으키는 테이블을 알려주었기 대문에 문제를 일으키는 쿼리를 바로 찾을 수 잇었고<br> 
해당 테이블에서 사용하는 쿼리를 보고 1차적으로 결합인덱스를 생성해야 겠다고 판단을 했다.<br> 

파트너번호와 거래일자 작업코드를 조건으로 조회를 하는 쿼리가 있는데 <br> 
기존 DB에 구조를 그래로 가져온 As-is에는<br> 
거래일자를 기준으로 걸려있는 인덱스A를 타고 조회를 해온다.<br> 

여기에 파트너번호와 거래일자로 결합 인덱스를 생성하여 조회를 한다면 조회 성능이 개선될 것이라 판단했다.<br> 
개발 디비에서 카디널리티가 높은순에서 낮은순으로 인덱스B(파트너번호 > 거래일자) 구성<br> 

같은 쿼리를 각각 다른 인덱스를 통해 조회를 하고 mysql profiling 기능으로 비교를 해봤다.<br> 
확인해보니 예상대로 인덱스B가 인덱스A보다 나은 수치를 보입니다.<br> 

한번의 조회시 좀 더 나은건 맞지만 획기적인 성능차이가 보이지는 않는다.<br> 
결합 인덱스를 생성한 이유는 조회시 속도의 개선도 있지만 consumer application에서 큐에 쌓인 정보를 토대로<br> 
동시다발적으로 조회를 CPU점유율을 낮추기 위한 목적이었습니다.<br> 

평균적으로 40만건의 큐에서 조회 조건 데이터를 가져와 40만번의 조회를 시도합니다.<br> 
개발환경에서 1-2천의 조회시에는 문제가 되지 않았지만 운영기준에 40만번의 조회에서는<br> 
점점 cpu 사용률이 증가하고 대기하게 되는 상황이 오게되어 지연현상이 발생한 것으로 보였기 때문에<br> 
cpu사용률을 줄이기 위해 결합인덱스를 추가하였습니다.<br> 

운영 DB에 인덱스B를 추가하고  같은 작업시 DB파트에서 전과 같은 지연현상이 발생하지 않는다고 연락받았습니다. <br> 


아래링크는 sql최적화에 대한 좋은 내용인거같다.<br> 
https://www.kdata.or.kr/info/info_04_view.html?field=&keyword=&type=techreport&page=221&dbnum=127626&mode=detail&type=techreport


### 트러블이슈해결2
특정 연동 업체를 통해 주문한 것을 취소시 연동업체에서 정해준 API로 호출해줘 알려주는 작업을 추가하였습니다.
리뷰 과정에서 연동업체에 문제가 생겨서 API timeout난 경우에는 어떻게 처리할 것인지 피드백을 받았습니다.
취소 처리 flow는 취소버튼을 클릭하면 ajax를 통해 취소 API를 호출하면 사용자에게는 로딩화면이 보이고 API에서
취소 관련 로직처리와 추가 작업들이 모두 완료되어 응답을 받으면 취소완료 페이지가 정상적으로 사용자한테 노출된다.

하지만 이런 정상적인 케이스가 아닌 취소 API에서 외부 연동 API를 호출하고 응답을 기다리는 상황에서 연동 API에 문제가
발생한다면 사용자는 timeout 발생할때까지 로딩페이지를 보고있는 문제가 발생한다.

그래서 외부연동업체 API호출을 추가 작업 로직중에서 비동기로  분리해되는 것들은 요청으로 처리하여 피드백건을
해결했습니다.

`기본 사용`<br>
```java

CompletableFuture.runAsync(task)

```

`스레드 풀 설정 후 사용`<br>
```java
Executor executor = Executors.newFixedThreadPool(10);

CompletableFuture.runAsync(task,executor)

```
* newFixedThreadPool
    * 처리할 작업이 등록되면 그에 따라 실제 작업할 스레드를 하나씩 생성한다. 생성할 수 있는 쓰레드의 최대 개수는 제한되어 있으며, 제한된 개수까지 쓰레드를 생성한 후 쓰레드를 유지한다. 

* newCachedThreadPool
    * 캐시 쓰레드풀은 현재 갖고 있는 쓰레드의 수가 처리할 작업의 수보다 많아서 쉬는 쓰레드가 많이 발생할 때 쉬는 쓰레드를 종료시켜 훨씬 유연하게 대응할 수 있다. 처리할 작업의 수가 많아지면 그만큼 쓰레드를 생성한다. 반면에 쓰레드의 수에는 제한을 두지 않는다.

* newSingleThreadExecutor
    * 단일 쓰레드로 동작하는 Executor 로서 작업을 처리하는 쓰레드가 단 하나뿐이다.

* newScheduledThreadPool
    * 일정 시간 이후에 실행하거나 주기적으로 작업을 실행할 수 있으며, 쓰레드의 수가 고정되어 있는형태의 Executor.Timer 클래스의 기능과 유사하다. 



### 힌트를 사용해서 쿼리 지정해주기
배치 쿼리중에 성능이 나오지 않는 쿼리가 있어 explain으로 실행계획을 확인하여
타고 있는 인덱스를 확인해보니 cardinalilty가 높지 않는 A칼럼의 인덱스를 타고 있었고
업무적으로도 B칼럼을 기준으로 인덱스를 타는게 필터해야 하는 대상이 적을 것이라고 판단하여
인덱스 힌트를 줘 조회 시간을 단축 시킨 경험이 있습니다.

`힌트 사용`<br>
```sql

SELECT * FROM t USE INDEX(인덱스 명) 

```

`추가 참고사항`<br>
* group by
mysql의 경우  group by를 하면 정렬도 같이 해주기 때문에<br>
explain의 실행계획에 filesort가 같이 찍힌다. <br>
정렬이 필요 없는 경우라면 `order by null`을 선언해준다면 filesort를 제거 할 수 있다.



### ehcache 적용을 통해 카테고리 조회 개선

